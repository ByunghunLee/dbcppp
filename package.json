{
  "name": "dbcppp",
  "version": "0.0.2",
  "description": "[![Build Status](https://travis-ci.org/xR3b0rn/dbcppp.svg?branch=master)](https://travis-ci.org/xR3b0rn/dbcppp)\r # dbcppp\r A C/C++ DBC file parser based on `boost.spirit`. This library is designed for decoding performance.\r # Features\r * very fast decoding\r * verbose parser output in error case\r * DBC is editable through C/C++ interface exported from the library\r * read/write DBC file\r * decode functionality for frames of arbitrarily byte length\r * cantools like decoding\r ## DBC data types\r ### Supported\r * version\r * new_symbols\r * bit_timing\r * nodes\r * value_tables\r * messages\r * message_transmitters\r * environment_variables\r * environment_variables_data\r * signal_types\r * comments\r * attribute_definitions\r * attribute_defaults\r * attribute_values\r * value_descriptions\r * signal_extended_value_type_list\r ### Not supported yet\r * sigtype_attr_list\r * signal_type_refs\r * signal_groups\r # Getting started\r ## Dependencies\r * boost\r ## Build & Install\r ```\r git clone https://github.com/xR3b0rn/dbcppp.git\r cd dbcppp\r mkdir build\r cd build\r cmake ..\r make -j\r make RunTests\r make install\r ```\r # Usage example\r ## Command line tool\r ### dbc2\r ```\r # generate C source from DBC\r dbcppp dbc2 --dbc=file.dbc --format=C --out=file.h\r # beauty or merge DBC\r dbcppp dbc2 --dbc=file1.dbc --dbc=file2.dbc --format=DBC --out=merged.dbc\r ```\r This feature isn't well tested. Especially the C generator does have a high chance of generating erroneous code.\r ### decode\r [cantools](https://github.com/eerimoq/cantools) like decoding:\r ```\r candump any | dbcppp decode --bus=vcan0,file1.dbc --bus=vcan1,file2.dbc\r ```\r ## Library\r * [Examples](https://github.com/xR3b0rn/dbcppp/tree/master/src/Examples)\r * `C++`\r ```C++\r #include <fstream>\r #include <dbcppp/Network.h>\r int main()\r {\r     std::ifstream dbc_file{\"your_dbc.dbc\"};\r     std::unique_ptr<dbcppp::Network> net = dbcppp::Network::fromDBC(dbc_file);\r     if (net)\r     {\r         can_frame frame;\r         while (1)\r         {\r             receive_can_frame_from_somewhere(&frame);\r             const Message* msg = net->getMessageById(frame.id);\r             if (msg)\r             {\r                 std::cout << \"Received message: \" << msg->getName() << std::endl;\r                 msg->forEachSignal(\r                     [&](const Signal& signal)\r                     {\r                         uint64_t raw = signal.decode(frame.data);\r                         std::cout << \"\\t\" << signal.getName() << \"=\" << signal.rawToPhys(raw) << std::endl;\r                     });\r             }\r         }\r     }\r }\r ```\r * `C`\r ```C\r #include <stdio.h>\r #include <dbcppp/CApi.h>\r int main()\r {\r     const dbcppp_Nework* net = dbcppp_NetworkLoadDBCFromFile(\"your_dbc.dbc\");\r     if (net)\r     {\r         can_frame frame;\r         while (1)\r         {\r             receive_can_frame_from_somewhere(&frame);\r             const dbcppp_Message* msg = dbcppp_NetworkGetMessageById(net, frame.id);\r             if (msg)\r             {\r                 printf(\"Received message: %s\\n\", dbcppp_MessageGetName(msg));\r                 void print_signal_data(const dbcppp_Signal* sig, void* data)\r                 {\r                     can_frame* frame = (can_frame*)data;\r                     uint64_t raw = dbcppp_SignalDecode(sig, frame->data);\r                     double phys = dbcppp_SignalRawToPhys(sig, raw);\r                     printf(\"\\t%s=%f\\n\", dbcppp_SignalGetName(sig), phys);\r                 }\r                 dbcppp_MessageForEachSignal(msg, print_signal_data, &frame);\r             }\r         }\r     }\r }\r ```\r # Decode-function\r The signals decode function is using prestored masks and fixed offsets to speed up calculation, therefore the decoding-function should be almost as fast as a code generated decode function would be. The assembly of the `decode`-function on its critical path (signed and byte swap must happen) looks like this (VS19 10.0.18362.0 compiler):\r ```\r template <Alignment aAlignment, Signal::ByteOrder aByteOrder, Signal::ValueType aValueType, Signal::ExtendedValueType aExtendedValueType>\r double template_decode(const Signal* sig, const void* nbytes) noexcept\r 00007FF8025BCA73  mov         rax,rcx  \r 00007FF8025BCA76  mov         rcx,qword ptr [rcx+140h]  \r 00007FF8025BCA7D  xorps       xmm0,xmm0  \r 00007FF8025BCA80  bswap       r8  \r 00007FF8025BCA83  shr         r8,cl  \r 00007FF8025BCA86  and         r8,qword ptr [rax+130h]  \r 00007FF8025BCA8D  mov         rcx,qword ptr [rax+138h]  \r 00007FF8025BCA94  mov         rax,rcx  \r 00007FF8025BCA97  or          rcx,r8  \r 00007FF8025BCA9A  and         rax,r8  \r 00007FF8025BCA9D  cmove       rcx,r8  \r 00007FF8025BCAA1  cvtsi2sd    xmm0,rcx  \r 00007FF8025BCAA6  ret   \r ```\r On the best path (no byteswap must take place and ExtendedValueType == Double) the decode function only has 5 instructions:\r ```\r template <Alignment aAlignment, Signal::ByteOrder aByteOrder, Signal::ValueType aValueType, Signal::ExtendedValueType aExtendedValueType>\r double template_decode(const Signal* sig, const void* nbytes) noexcept\r 00007FF8025BCAF0  mov         rax,qword ptr [rdx]  \r 00007FF8025BCAF3  mov         qword ptr [rsp+8],rcx  \r 00007FF8025BCAF8  mov         qword ptr [sig],rax  \r 00007FF8025BCAFD  movsd       xmm0,mmword ptr [data]  \r 00007FF8025BCB03  ret  \r ```\r # Known issues\r * tests for decoding function for float/double is failing on some maschines (currently only confirmed for System/s390x)\r # Similar projects\r   * [Vector_DBC](https://bitbucket.org/tobylorenz/vector_dbc/src/master/) Does basically the same, the biggest difference is that it uses `bison` instead of `boost::spirit` for grammar parsing\r   * [CAN BUS tools in Python 3 (cantools)](https://github.com/eerimoq/cantools)",
  "main": "index.js",
  "dependencies": {
    "cz-conventional-changelog": "^3.2.0",
    "standard-version": "^8.0.0"
  },
  "devDependencies": {},
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/xR3b0rn/dbcppp.git"
  },
  "author": "Julian Hindelang",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/xR3b0rn/dbcppp/issues"
  },
  "homepage": "https://github.com/xR3b0rn/dbcppp#readme"
}
